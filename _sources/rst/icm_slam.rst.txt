.. _ICM SLAM:

ICM SLAM
===================

Instalación ICM_SLAM + ROS
--------------------------
A continuación se desarrollan los pasos que hay que seguir para poder ejecutar el algoritmo ICM_SLAM en una red ROS.

 - Inicialmente es necesario instalar `Docker <https://docs.docker.com/get-docker/>`_  
 - Descargar la última versión de la `implementación en ros <https://www.mediafire.com/file/esaom1qt9yf2lyh/ros_implementation_v2_1.zip/file>`_
 - Descomprima el archivo .zip descargado. Abra una terminal del sistema operativo y dirijase a la carpeta en donde descomprimió el archivo.

 - Luego ingrese el siguiente comando.

.. code-block:: bash

 docker build -t ros-bridge .

Se van a descargar unos paquetes, esta operación puede tardar mucho tiempo. Depende de su velocidad de conexión.

 - Una vez que finalice el anterior paso, ejecutar:

.. code-block:: bash

 docker-compose up -d 

Este comando va a crear una red ROS funcionando en background. Es necesario que quede corriendo mientras se trabaja con ROS ya que además de generar un puente entre la virtualización (mediante Docker) y la maquina host, corre tambien *roscore*. Esta última aplicación es necesaria para que funcione ROS.
Para desactivarlo, ingrese el siguiente comando:

.. code-block:: bash

 docker-compose down

En esta misma carpeta hay otra carpeta que se llama "bags". Esta es una carpeta compartida con la virtualizacion, los datos almacenados en la carpeta "bags" apareceran en la carpeta "/home" de la virtualizacion. Si desea compartir otra carperta debe modificar el archivo docker-compose.yml y en la linea donde dice "source: ./bags" rempleazar ./bags por la ruta de la carpeta que desea compartir. 

 - Para reproducir un archivo *.bag* ejecutar en otra terminal:

 .. code-block:: bash

  docker exec -it docker_ros-bridge_1 bash

Luego, una vez dentro de la virtualización ingresar los siguientes comandos en orden:

 .. code-block:: bash

  cd /home
  source iniciar.sh

Ahora ya se esta en condiciones de ejecutar cualquier archivo .bag, por ejemplo lo puede hacer de la siguiente manera:

 .. code-block:: bash
 
  rosbag play data.bag

Esto reproducirá la grabación almacenada en *data.bag* . Si preciona la tecla *space* la repdocucción se pausará. Si preciona la combinación de teclas *ctrl+c* se corta la reproducción.

Una vez de realizado el anterior procedimiento, se esta en condiciones de probar el algoritmo *icm_slam*. Para esto descargar la última versión disponible en `icm_slam <https://www.mediafire.com/file/yi6tg57fel15laz/ros_bridge_v2_1.zip/file>`_ e instalar `Python 3 <https://www.python.org/downloads/>`_ si es que no lo tiene aún. Luego siga las siguientes instrucciones:

 - Descomprimir el archivo.
 - En la carpeta que descomprimió el archivo ejecutar los siguientes comandos para preparar el entorno de ejecución:

 .. code-block:: bash

  python3 -m venv env
  source env/bin/activate
  python -m pip install -U pip
  python3 -m pip install -r requisitos.txt

Ya se esta en condiciones de ejecutar el algoritmo. Para esto, debe poner en funcionamiento la virtualización (mediante el comando *docker-compose up -d* ) , luego en la carpeta donde descomprimió ejecutar:


 .. code-block:: bash

  python example.bag

Si todo funciona correctamente debería salir el mensaje: "Conectado a la red ROS".

 - Cuando se comience a reproducir una base de datos, el código de python comenzará a recibir la información y creará una imagen con la trayectoria y el mapa estimado. 


Instalación ICM_SLAM 
---------------------

Es posible correr el algoritmo sin que intervenga ROS. Para esto descargar el código fuente en *icm_slam* e implementar las modificaciones necesarias. (?)  

Explicación del funcionamiento (desactualizado)
------------------------------------------------

La idea de este modulo es poder configurar el slam desde *external_options.py* y *config_default.yaml*. 

external_options
-----------------

En este archivo se define la estructura del programa principal y se ejecutan los modulos de *ICM_SLAM.py*. Para un correcto funcionamiento es encesario definir:

**g**: Ec. cinemática del vehículo. Definida en :cite:label:`gimenez2018`. 
   

.. code-block:: python 
 
 def g(self, xt,ut):
     xt=xt.reshape((3,1))
     ut=ut.reshape((2,1))
     S=np.array([[(np.cos(xt[2]))[0],0.0],
         [np.sin(xt[2])[0],0.0],
         [0.0,1.0]])
     gg=xt+self.config.deltat*np.matmul(S,ut).reshape((3,1))
     return gg


**h**: Ec. de medición. Definida en :cite:label:`gimenez2018`. Poner un ejemplo de implementación.

.. code-block:: python


    def h(self, xt,zt):
        y=self.mapa_visto
        alfa=zt[:,1]+xt[2]-np.pi/2.0
        zc=zt[:,0]*np.cos(alfa)
        zs=zt[:,0]*np.sin(alfa)
        # Resta la posicion de cada punto al mapa "visto". (y no es todo el mapa,
        # solo la parte matcheada en "actualizar mapa")
        distancias=np.concatenate((xt[0]+zc,xt[1]+zs)).reshape((len(alfa),2),order='F')-y
        # Calcula la norma :math:`hh^TQhh`
        aux=np.matmul(distancias,self.config.Q)
        potencial=np.sum(aux*distancias)
        return potencial


Optativamente
************** 

**fun_x**: Es el argumento de la función definido en la Ec. (11) de :cite:label:`gimenez2018`. Es necesario que dicha función devuelva un valor pequeño para aquellos valores más probables del estado del robot y valores grandes para valores mas improbables. Esta función puede depender de cualquier señal **causal** (que depende solo del tiempo actual y de los pasados). Ya que se ejecutará en la etapa de inicialización **online**. 

 .. code-block:: python


    def fun_x(self,x):
        """
        Argumento de la Ec. (11) del paper.

        Función a minimizar que depende de:
         - Odometria
         - Estimacion de pose anterior
         - Modelo cinemático de movimiento
         - Modelo de las observaciones
         - Observaciones en un instate dado
        
        Parámetros
        -----------
        
        Entrada:
         - x: posición.

        Salida:
         - f: potencial energético.

        """

        z=self.medicion_actual
        x_ant=self.x_ant_opt
        u_ant=self.u_ant_opt
        odo=self.odo_opt
        # vector desplazamiento entre las estimacion de pose anterior y la pose
        # actual X.
        gg=x.reshape((3,1))-self.g(x_ant,u_ant)
        gg[2]=entrepi(gg[2])

        hh=self.h(x,z)
        Rotador=Rota(x_ant[2][0])
        ooo=np.zeros((3,1))
        # Calcula la diferencia entre los vectores desplazamiento. Entre la
        # odometria y la pose x (de forma relativa, con respecto a la pose anterior)
        # Ec. (16) del paper.
        ooo[0:2]=np.matmul(Rota(odo[2,0]),(odo[0:2,1]-odo[0:2,0]).reshape((2,1)))\
                -np.matmul(Rotador,x[0:2].reshape((2,1))-x_ant[0:2])
        
        ooo[2]=odo[2,1]-odo[2,0]-x[2]+x_ant[2]
        ooo[2]=entrepi(ooo[2])

        f=np.matmul(np.matmul(gg.T,self.config.R),gg)+\
           hh+\
           self.config.cte_odom*np.matmul(ooo.T,ooo)
        return f

**fun_xn**: Es el argumento de la función definido en la Ec. (14) de :cite:label:`gimenez2018`. Es necesario que dicha función devuelva un valor pequeño para aquellos valores más probables del estado del robot y valores grandes para valores mas improbables. Esta función puede depender de cualquier señal. Ya que se ejecutará en la etapa de optimizacion **offline**. En general dicha función puede incluir en su calculo la salida de la funcion *fun_x*. 

.. code-block:: python


    def fun_xn(self,x):
        """
        Función a minimizar. 

        Parte del argumento de la Ec. (14) del papaer. Esta función incluye a
        fun_x, ya que usa la información previa (fun_x) e información futura.
        En este codigo solo se incorpora la información futura. 

        Entrada:
         - x: Pose

        Salida:
         - f: Potencial energético debido al modelo cinemático y a la
           odometría.
        """
        x_pos=self.x_pos_opt
        u_act=self.u_act_opt
        odo=self.odo_opt

        f=self.fun_x(x)

        x=x.reshape((3,1))
        gg=self.g(x,u_act)-x_pos
        gg[2]=entrepi(gg[2])

        Rotador=Rota(x[2][0])
        ooo=np.zeros((3,1))
        # Calcula la diferencia entre los vectores desplazamiento. Entre la
        # odometria y la pose x (de forma relativa, con respecto a la pose anterior)
        # Ec. (16) del paper.
        ooo[0:2]=np.matmul(Rota(odo[2,1]),(odo[0:2,2]-odo[0:2,1]).reshape((2,1)))\
                -np.matmul(Rotador,x_pos[0:2]-x[0:2])

        ooo[2]=odo[2,2]-odo[2,1]-x_pos[2]+x[2]
        ooo[2]=entrepi(ooo[2])

        f=np.matmul(np.matmul(gg.T,self.config.R),gg)\
           +self.config.cte_odom*np.matmul(ooo.T,ooo)\
           +f
        return f



config_default.yaml
--------------------

En este archivo se definen los parámetros de configuración del sistema. A continuación se pone una copia de los datos utilizados en  :cite:label:`gimenez2018`.

.. code-block:: yaml
    :name: config_default.yaml

    D:
        N: 2
        deltat: 0.1
        L: 1000  
        Q: [1,1]
        R: [1,1,1] 
        cte_odom: 1.0  
        cota: 300.0  
        dist_thr: 1.0  
        dist_thr_obs: 1  
        rango_laser_max: 10.0  
        radio: 0.137 

Definiciones
*************

 - N: Cantidad de iteraciones ICM.
 - deltat: Periodo de muestreo. 
 - Tf: Cantidad total de periodos de muestreo.
 - L: cota superior de la cantidad de objetos (max landmarks).
 - Q: Diagonal de la matriz que define la norma de las observaciones.
 - R: Diagonal de la matriz que define la norma del modelo de moviemiento.
 - S: Diagonal de la matriz que define la norma de la odometría.
 - cota: Cantidad de veces que hay que ver un árbol para q se considere un árbol.
 - dist_thr: Distancia máxima para que dos obs sean consideradas del mismo objeto.
 - dist_thr_obs: Distancia máxima para que dos obs sean consideradas del mismo objeto en el proceso de filtrado de las observaciones.
 - rango_laser_max: Alcance máximo del laser.
 - radio: Radio promedio de los árboles.

Implementaciones
----------------
En la actualidad se encuentra implementado el codigo en python para un dataset offline almacenado en un archivo .mat . En la brevedad se terminará de desarrollar el código para correrlo en una red ROS. 

 - Para mayor informacion ir a la rama *master* del repositorio.
 - En la rama *ros_package* se encuentra el desarrollo de la implementacion en la red ROS.


Procedimiento
--------------

Este package no es propiamente un package de ROS, ya que no requiere tener inicializado el entorno. Para usar los scripts con la red ROS se requiere estar corriendo en *ros-master* el modulo `rosbridge <http://wiki.ros.org/rosbridge_suite>`_. Una vez instalado este modulo ejecutar:

.. code-block:: bash

    roslaunch rosbridge_server rosbridge_websocket.launch

A modo de resumen, rosbridge es una inteerfaz de ROS que permite conectar a la red programas que no contienen modulos de ROS. En este caso se utiliza la libreria `roslibpy <https://roslibpy.readthedocs.io/en/latest/>`_ ya que permite conectar códigos escritos en python 3.xx a ROS (ROS funciona con python 2.7). 

Una vez inicializado *rosbridge* el modulo *sensors.py* busca conectarse a la red ROS y accede a los topics de los sensores. Por defecto busca el topic del laser y de la odometria, los cuales deben especificarse en el archivo de configuración *config_ros.yaml* en *topic_laser* y *topic_odometry* respectivamente.

El software no diferencia si los datos vienen de una simulación que esta corriendo, si son datos de un robot que está compartiendo los datos de sus sensores via streaming, o son datos grabados en un archivo *.bag*. Por este motivo en esta ocasión se utiliza la última opción. 

Aún no está implementada la posibilidad de de ejecutar un *.bag* sin tener funcionando la red ROS. Con lo cual, se requiere tener instalado ROS para ejecutar el siguiente comando:

.. code-block:: bash

    rosbag play slam_benchmark/bags/laser_data.bag

Asumiendo que el *PWD* está en la carpeta *src* del *workspace*. Luego lanzar el script haciendo:


.. code-block:: bash

    source ICM_SLAM/scripts/env/bin/activate
    python ICM_SLAM/scripts/sensors.py


Funcionamiento script sensors.py
----------------------------------

Este script se subscribe a los topics antes dichos y genera un servicio que habilita las iteraciones ICM. (Esto se podrá implementar en un futuro con  `ActionLib <http://wiki.ros.org/actionlib>`_ más info en `ActionLib Detailed Description. <http://wiki.ros.org/actionlib/DetailedDescription>`_).

Básicamente el comportamiento del servicio es que mediante el comando "start", comienza a iterar la cantidad de veces especificadas en el *.yaml* y luego devuelve el mapa y la trayectoria del vehículo. 






.. .. autoclass:: ICM_SLAM.scripts.ICM_SLAM.ICM_method
    :members:
    :undoc-members:


.. .. autofunction:: ICM_SLAM.scripts.funciones_varias
  
 

 



.. .. autosummary::
   :toctree:  _autosummary
   :recursive:
   
   ICM_SLAM.scripts.ICM_SLAM



.. .. toctree::
    

    modularTree_code
